<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schale Intelligence | Deep Dive Protocol</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;500;700;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* 基础色板 */
            --ba-pink: #ffaab2;
            --ba-pink-dark: #ff8e99;
            --ba-blue-accent: #6AD9F5;
            --ba-text: #4c5b70;
            --glass-bg: rgba(255, 255, 255, 0.82);
            --glass-border: rgba(255, 255, 255, 0.9);
            
            /* 氛围光效 */
            --inner-glow: inset 0 0 20px rgba(106, 217, 245, 0.15);
            --scratch-filter: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.5' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E");
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            margin: 0; padding: 20px;
            font-family: "M PLUS Rounded 1c", sans-serif;
            color: var(--ba-text);
            background: #fdfdfd;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            perspective: 1200px; /* 开启3D透视 */
        }

        /* ─── 0. 极简故障 (Step Glitch) ─── */
        /* 克制：极短时间内的位移跳变，不使用模糊或色差，追求纯粹的"信号丢失"感 */
        @keyframes glitch-snap {
            0% { transform: translate(0); }
            20% { transform: translate(-3px, 0); }
            40% { transform: translate(3px, 0); }
            60% { transform: translate(-3px, 0); }
            100% { transform: translate(0); }
        }

        .glitch-snap-active {
            /* steps(2, end) 造成机械的卡顿感 */
            animation: glitch-snap 0.05s steps(2, end) 1;
            filter: brightness(1.3) contrast(1.2);
        }

        /* ─── 1. 容器深度 (Depth Container) ─── */
        .container {
            width: 100%; max-width: 600px;
            background: var(--glass-bg);
            backdrop-filter: blur(24px) saturate(120%);
            -webkit-backdrop-filter: blur(24px) saturate(120%);
            border-radius: 18px;
            border: 1px solid var(--glass-border);
            /* 物理光泽 */
            box-shadow: 
                0 20px 50px rgba(0,0,0,0.05),
                0 1px 0 rgba(255,255,255,0.8) inset,
                var(--inner-glow); 
            position: relative;
            transform-style: preserve-3d; /* 保持3D空间 */
            transition: transform 0.1s cubic-bezier(0.2, 0, 0.2, 1); /* 极其顺滑的跟随 */
            will-change: transform;
        }

        /* 划痕层 - 模拟旧玻璃面板 */
        .container::after {
            content: ''; position: absolute; inset: 0;
            background-image: var(--scratch-filter);
            opacity: 0.4;
            pointer-events: none;
            z-index: 2;
            border-radius: 18px;
            mix-blend-mode: overlay;
        }

        /* ─── 2. 内部 UI 结构 ─── */
        .header {
            padding: 24px 24px 10px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .title h1 {
            margin: 0; font-size: 24px; font-weight: 800;
            font-style: italic; letter-spacing: 1px;
        }
        .title span {
            display: block; font-size: 10px; color: var(--ba-pink);
            font-family: "JetBrains Mono", monospace; letter-spacing: 2px;
        }

        /* 语录显示器 */
        .decoder-box {
            margin: 10px 24px;
            padding: 16px;
            background: rgba(255,255,255,0.5);
            border-left: 3px solid var(--ba-pink);
            border-radius: 0 8px 8px 0;
            font-size: 14px;
            line-height: 1.6;
            min-height: 54px;
            font-family: "JetBrains Mono", "M PLUS Rounded 1c", monospace;
            position: relative;
        }
        /* 光标 */
        .cursor {
            display: inline-block; width: 8px; height: 14px;
            background: var(--ba-blue-accent);
            animation: blink 1s step-end infinite;
            vertical-align: middle;
            margin-left: 4px;
        }
        @keyframes blink { 50% { opacity: 0; } }

        /* 频谱与播放器 */
        .audio-section {
            padding: 20px 24px;
            display: flex; align-items: center; gap: 15px;
        }
        
        /* 核心呼吸灯 */
        .core-halo {
            width: 40px; height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, #fff 30%, var(--ba-blue-accent) 100%);
            box-shadow: 0 0 20px var(--ba-blue-accent);
            position: relative;
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        .core-halo::before {
            content: ''; position: absolute; inset: -4px;
            border: 1px dashed rgba(106, 217, 245, 0.6);
            border-radius: 50%;
            animation: rotate-slow 10s linear infinite;
        }
        @keyframes rotate-slow { to { transform: rotate(360deg); } }

        /* 频谱条容器 */
        .spectrum-viz {
            display: flex; align-items: flex-end; gap: 4px;
            height: 30px; flex-grow: 1;
        }
        .bar {
            width: 4px; background: var(--ba-blue-accent);
            border-radius: 2px; height: 4px;
            transition: height 0.08s ease-out; /* 增加一点阻尼 */
        }

        /* 交互按钮 */
        .play-trigger {
            background: none; border: 1px solid var(--ba-text);
            border-radius: 20px; padding: 6px 16px;
            font-family: "JetBrains Mono", monospace;
            font-size: 11px; font-weight: 700;
            cursor: pointer; transition: all 0.2s;
            color: var(--ba-text);
        }
        .play-trigger:hover {
            background: var(--ba-text); color: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        /* 装饰性侧栏文字 */
        .decor-text {
            position: fixed; right: 20px; bottom: 20px;
            writing-mode: vertical-rl;
            font-family: "JetBrains Mono";
            font-size: 10px; opacity: 0.3;
            letter-spacing: 4px;
        }

    </style>
</head>
<body>

    <div class="decor-text">SCHALE_DB // VER.3.5.0</div>

    <div class="container" id="panel">
        <div class="header">
            <div class="title">
                <h1>SCHALE</h1>
                <span>INTELLIGENCE TERMINAL</span>
            </div>
            <div style="font-family:'JetBrains Mono'; font-size:12px; opacity:0.6;" id="clock">00:00:00</div>
        </div>

        <div class="decoder-box">
            <span id="output-text"></span><span class="cursor"></span>
        </div>

        <div class="audio-section">
            <div class="core-halo" id="core"></div>
            <div class="spectrum-viz" id="spectrum">
                <div class="bar"></div><div class="bar"></div><div class="bar"></div>
                <div class="bar"></div><div class="bar"></div><div class="bar"></div>
                <div class="bar"></div><div class="bar"></div>
            </div>
            <button class="play-trigger" id="play-btn">CONNECT</button>
        </div>
    </div>

    <audio id="audio-source" src="https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.m4a" crossorigin="anonymous"></audio>
    <script>
    /**
     * SCHALE INTELLIGENCE TERMINAL - LOGIC CORE
     * Focus: Restraint, Rhythm, Atmosphere
     */

    // ─── 1. 深度交互逻辑 (Tilt Effect) ───
    const panel = document.getElementById('panel');
    const updateTilt = (e) => {
        // 计算鼠标相对于窗口中心的坐标 (-1 到 1)
        const x = (e.clientX / window.innerWidth) * 2 - 1;
        const y = (e.clientY / window.innerHeight) * 2 - 1;

        // 极轻微的倾斜 (Max 1.5deg) 保持高级感
        // X轴旋转由Y坐标控制，Y轴旋转由X坐标控制（反向）
        panel.style.transform = `perspective(1000px) rotateX(${-y * 1.5}deg) rotateY(${x * 1.5}deg)`;
    };
    
    // 节流处理，避免过高频触发导致掉帧
    let tiltFrame;
    document.addEventListener('mousemove', (e) => {
        if (tiltFrame) cancelAnimationFrame(tiltFrame);
        tiltFrame = requestAnimationFrame(() => updateTilt(e));
    });


    // ─── 2. 簇状停顿打字机 (Burst Typing) ───
    const outputEl = document.getElementById('output-text');
    const targetText = "Connecting to Shittim Chest... Access Granted. Welcome back, Sensei. Today's agenda has been updated.";
    
    // 模拟人类思考节奏的打字函数
    const typeWriter = async (text) => {
        outputEl.innerText = "";
        let i = 0;
        
        while (i < text.length) {
            // 决定这一簇打多少个字 (3-7个)
            const burstLen = Math.floor(Math.random() * 5) + 3; 
            const currentBurst = text.slice(i, i + burstLen);
            
            // 快速输出这一簇
            for (let char of currentBurst) {
                outputEl.innerText += char;
                // 字与字之间极短的物理延迟 (20-50ms)
                await new Promise(r => setTimeout(r, 20 + Math.random() * 30));
            }
            
            i += burstLen;

            // 簇与簇之间的“思考”停顿 (长短不一, 100ms - 500ms)
            // 偶尔出现较长的停顿模拟“加载”或“斟酌”
            const isLongPause = Math.random() > 0.8;
            const pauseTime = isLongPause ? 600 : 100 + Math.random() * 200;
            
            if (i < text.length) await new Promise(r => setTimeout(r, pauseTime));
        }
    };


    // ─── 3. 视觉循环与音频 (Visual Loop & Heartbeat) ───
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const audioElement = document.getElementById('audio-source');
    const playBtn = document.getElementById('play-btn');
    let source, analyser, dataArray;
    let isPlaying = false;
    let isInit = false;

    function initAudio() {
        if (isInit) return;
        source = audioCtx.createMediaElementSource(audioElement);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 64;
        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        isInit = true;
    }

    const bars = document.querySelectorAll('.bar');
    const core = document.getElementById('core');

    // 核心渲染循环 (持续运行)
    function renderLoop() {
        requestAnimationFrame(renderLoop);
        
        const now = Date.now(); // 用于生成静默波形的时间因子

        if (isPlaying) {
            // ── 模式 A: 活跃态 (音频驱动) ──
            analyser.getByteFrequencyData(dataArray);
            
            // 计算平均音量用于核心光环
            let sum = 0;
            bars.forEach((bar, idx) => {
                // 取样: 略过极低频，每隔几个取样
                const val = dataArray[idx * 2 + 2] || 0; 
                sum += val;
                
                // 映射高度 (4px - 24px)
                const h = 4 + (val / 255) * 20;
                bar.style.height = `${h}px`;
                bar.style.opacity = 1;
            });
            
            // 核心动态缩放
            const avg = sum / bars.length;
            core.style.transform = `scale(${0.9 + (avg/255)*0.3})`;
            core.style.boxShadow = `0 0 ${20 + avg/5}px var(--ba-blue-accent)`;

        } else {
            // ── 模式 B: 待命态 (静默脉动/Math.sin) ──
            // 核心: 缓慢的深呼吸
            const breath = Math.sin(now * 0.0015); // 极慢
            const scale = 0.95 + breath * 0.05; // 0.9 - 1.0
            core.style.transform = `scale(${scale})`;
            core.style.boxShadow = `0 0 ${15 + breath * 5}px rgba(106, 217, 245, 0.4)`;

            // 频谱: 像海浪一样起伏的微小波动
            bars.forEach((bar, idx) => {
                // 每个bar有相位差，形成波浪感
                const wave = Math.sin(now * 0.003 + idx * 0.5);
                const h = 5 + wave * 2; // 3px - 7px
                bar.style.height = `${h}px`;
                bar.style.opacity = 0.5; // 变暗
            });
        }
    }


    // ─── 4. 克制的 Glitch 触发器 ───
    function scheduleRandomGlitch() {
        // 随机间隔 15s - 30s
        const nextTime = 15000 + Math.random() * 15000;
        
        setTimeout(() => {
            // 触发 Glitch
            panel.classList.add('glitch-snap-active');
            
            // 50ms 后移除 (极短)
            setTimeout(() => {
                panel.classList.remove('glitch-snap-active');
            }, 50);

            // 递归调度下一次
            scheduleRandomGlitch();
        }, nextTime);
    }


    // ─── 控制逻辑 ───
    playBtn.addEventListener('click', () => {
        initAudio();
        
        // 恢复 AudioContext (浏览器策略)
        if (audioCtx.state === 'suspended') audioCtx.resume();

        if (isPlaying) {
            audioElement.pause();
            playBtn.innerText = "CONNECT";
            playBtn.style.background = "transparent";
            playBtn.style.color = "var(--ba-text)";
        } else {
            audioElement.play();
            playBtn.innerText = "ABORT";
            playBtn.style.background = "var(--ba-text)";
            playBtn.style.color = "#fff";
        }
        isPlaying = !isPlaying;
    });

    // ─── 初始化 ───
    (function init() {
        // 启动时钟
        setInterval(() => {
            document.getElementById('clock').innerText = new Date().toLocaleTimeString('en-GB');
        }, 1000);

        // 启动渲染循环
        renderLoop();

        // 启动文字
        typeWriter(targetText);

        // 启动随机故障
        scheduleRandomGlitch();
    })();

</script>
</body>
</html>
